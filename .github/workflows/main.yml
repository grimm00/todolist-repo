# .github/workflows/main.yml

# Name of the workflow, which will be displayed on the GitHub Actions tab.
name: Build, Test, and Deploy to Cloud Run

# This section defines the trigger for the workflow.
# In this case, it runs on any 'push' event to the 'main' branch.
on:
  push:
    branches:
      - main

# Environment variables available to all jobs and steps in the workflow.
env:
  PROJECT_ID: "todolist-465520"
  SERVICE_NAME: "todo-flask-app"
  REGION: "us-central1"

jobs:
  # --- JOB 1: Build, Test, and Push the Docker Image ---
  build-and-push:
    name: Build, Test, and Push Docker Image
    # Use the latest Ubuntu runner provided by GitHub.
    runs-on: ubuntu-latest

    # These permissions are required for the GCP authentication action.
    # It allows the workflow to get an OIDC token from GitHub.
    permissions:
      contents: 'read'
      id-token: 'write'
    
    # Define the output of this job, which will be the image tag.
    # The 'deploy' job will use this output.
    outputs:
      image_tag: ${{ steps.define_tag.outputs.image_tag }}
    
    steps:
      # Step 1: Check out the repository's code so the workflow can access it.
      - name: Step 1: Checkout code
        uses: actions/checkout@v4

      # Step 2: Authenticate to Google Cloud.
      # This uses Workload Identity Federation to securely log in without service account keys.
      - name: Step 2: Authenticate to Google Cloud
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: '${{ secrets.GCP_WIF_PROVIDER }}'
          service_account: '${{ secrets.GCP_SERVICE_ACCOUNT }}'

      # Step 3: Set up the gcloud CLI tool.
      - name: Step 3: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'

      # Step 4: Configure Docker to authenticate with Google Artifact Registry.
      # This allows the 'docker push' command to work.
      - name: Step 4: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      # Step 5: Define the image tag using an environment variable for reusability.
      - name: Step 5: Define and expose image tag
        id: define_tag
        run: |
          TAG="${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}"
          echo "IMAGE_TAG=$TAG" >> $GITHUB_ENV
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      # Step 6: Build the Docker image, tagging it for Artifact Registry.
      - name: Step 6: Build Docker image
        run: docker build -t ${{ env.IMAGE_TAG }}:latest .

      # Step 7: Test the container locally on the runner.
      # This replicates the local test stage from your script to ensure the container runs
      # and responds correctly before it gets pushed.
      - name: Step 7: Test Docker image locally
        run: |
          CONTAINER_ID=$(docker run -d -p 8080:8080 ${{ env.IMAGE_TAG }}:latest)
          # 'trap' ensures the container is stopped and removed even if the test fails.
          trap 'docker stop ${CONTAINER_ID} && docker rm ${CONTAINER_ID}' EXIT
          echo "Waiting for application to start..."
          sleep 10 
          echo "Testing application health..."
          curl --retry 5 --retry-delay 3 --retry-connrefused --fail http://localhost:8080/
          echo "✅ Local container test passed!"

      # Step 8: Push the successfully tested Docker image to Artifact Registry.
      - name: Step 8: Push Docker image to Artifact Registry
        run: docker push ${{ env.IMAGE_TAG }}:latest

  # --- JOB 2: Deploy the Image to Cloud Run ---
  deploy:
    name: Deploy to Cloud Run
    runs-on: ubuntu-latest
    needs: build-and-push
    
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      # Step 1: Authenticate to Google Cloud in this new job.
      - name: Step 1: Authenticate to Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: '${{ secrets.GCP_WIF_PROVIDER }}'
          service_account: '${{ secrets.GCP_SERVICE_ACCOUNT }}'
      
      # Step 2: Set up the gcloud CLI tool in this new job.
      - name: Step 2: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'
      
      # Step 3: Deploy the new image as a "staging" revision with no traffic.
      # This is our "Green Deployment" to test the app in the real cloud environment.
      - name: Step 3: Deploy Staging Revision (No Traffic)
        id: deploy_staging
        uses: google-github-actions/deploy-cloudrun@v2
        with:
          service: ${{ env.SERVICE_NAME }}
          region: ${{ env.REGION }}
          image: ${{ needs.build-and-push.outputs.image_tag }}:latest
          no_traffic: true
          flags: '--allow-unauthenticated'

      # Step 4: Run a health check against the private URL of the new revision.
      - name: Step 4: Test Staging Revision
        run: |
          echo "Testing new revision at ${{ steps.deploy_staging.outputs.url }}"
          curl --retry 5 --retry-delay 10 --retry-connrefused --fail ${{ steps.deploy_staging.outputs.url }}/
          echo "✅ Staging revision test passed!"

      # Step 5: If the test succeeds, promote the new revision to serve 100% of traffic.
      - name: Step 5: Promote Revision to Production
        if: success()
        run: |
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --to-revisions=LATEST=100 \
            --region=${{ env.REGION }}
          echo "✅ New revision is now live."

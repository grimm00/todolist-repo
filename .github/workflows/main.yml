# .github/workflows/main.yml

# Name of the workflow, which will be displayed on the GitHub Actions tab.
name: Build, Test, and Deploy to Cloud Run

# This section defines the trigger for the workflow.
# In this case, it runs on any 'push' event to the 'main' branch.
on:
  push:
    branches:
      - main

# Environment variables available to all jobs and steps in the workflow.
# These are taken from your 'build-deploy.sh' script.
env:
  PROJECT_ID: "todolist-465520"
  SERVICE_NAME: "todo-flask-app"
  REGION: "us-central1"

jobs:
  build-and-push:
    name: Build, Test, and Push Docker Image
    # Use the latest Ubuntu runner provided by GitHub.
    runs-on: ubuntu-latest

    # These permissions are required for the GCP authentication action.
    # It allows the workflow to get an OIDC token from GitHub.
    permissions:
      contents: 'read'
      id-token: 'write'
    
    # Define the output of this job, which will be the image tag.
    # The 'deploy' job will use this output.
    outputs:
      image_tag: ${{ steps.define_tag.outputs.image_tag }}
    
    steps:
      # Step 1: Check out the repository's code so the workflow can access it.
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Authenticate to Google Cloud.
      # This uses Workload Identity Federation to securely log in without service account keys.
      - name: Authenticate to Google Cloud
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: '${{ secrets.GCP_WIF_PROVIDER }}'
          service_account: '${{ secrets.GCP_SERVICE_ACCOUNT }}'

      # Step 3: Set up the gcloud CLI tool.
      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'

      # Step 4: Create Artifact Registry repository if it doesn't exist.
      - name: Create Artifact Registry repository
        run: |
          gcloud artifacts repositories create ${{ env.SERVICE_NAME }} \
            --repository-format=docker \
            --location=${{ env.REGION }} \
            --description="Docker repository for the to-do list application" || true

      # Step 5: Configure Docker to authenticate with Google Container Registry (GCR).
      # This allows the 'docker push' command to work.
      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      # Step 6: Define the image tag using an environment variable for reusability.
      - name: Define Image Tag
        id: define_tag
        run: |
          TAG="${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}"
          echo "IMAGE_TAG=$TAG" >> $GITHUB_ENV
          echo "image_tag=$TAG" >> $GITHUB_OUTPUT

      # Step 7: Build the Docker image, tagging it for GCR.
      # This is the equivalent of 'docker build' in your script.
      - name: Build Docker image
        run: docker build -t ${{ env.IMAGE_TAG }}:latest .

      # Step 8: Test the container locally on the runner.
      # This replicates the local test stage from your script to ensure the container runs
      # and responds correctly before it gets deployed.
      - name: Test Docker image
        run: |
          CONTAINER_ID=$(docker run -d -p 8080:8080 -e PORT=8080 ${{ env.IMAGE_TAG }}:latest)
          # 'trap' ensures the container is stopped and removed even if the test fails.
          trap 'docker stop ${CONTAINER_ID} && docker rm ${CONTAINER_ID}' EXIT
          echo "Waiting for application to start..."
          # Increased sleep time and added retries to curl for more reliability in the CI environment.
          sleep 10 
          echo "Testing application health..."
          curl --retry 5 --retry-delay 3 --retry-connrefused --fail http://localhost:8080/
          echo "✅ Container test passed!"

        # Step 9: Push the successfully tested Docker image to GCR.
      - name: Push Docker image to Artifact Registry
        run: docker push ${{ env.IMAGE_TAG }}:latest

  deploy:
    name: Deploy to Cloud Run
    runs-on: ubuntu-latest
    needs: build-and-push
    
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
        # Step 1: Deploy the new image to Cloud Run.
        # This uses an official Google action to handle the deployment.
      - name: Authenticate to Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: '${{ secrets.GCP_WIF_PROVIDER }}'
          service_account: '${{ secrets.GCP_SERVICE_ACCOUNT }}'

        # Step 2: Sets up Cloud SDK
      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'
      
        # Step 3: Green Deployment with no traffic to test app
      - name: Deploy Staging Revision (No Traffic)
        id: deploy_staging
        uses: google-github-actions/deploy-cloudrun@v2
        with:
          service: ${{ env.SERVICE_NAME }}
          region: ${{ env.REGION }}
          image: ${{ needs.build-and-push.outputs.image_tag }}:latest
          no_traffic: true
          flags: '--allow-unauthenticated'
          # NEW: This section injects the environment variables our app needs.
          env_vars: >- # Use >- to allow multi-line env vars
            INSTANCE_CONNECTION_NAME=${{ env.INSTANCE_CONNECTION_NAME }}
            DB_USER=todo_user
            DB_NAME=todos
          # NEW: This section securely injects our password from Secret Manager.
          secrets: >- # Use >- to allow multi-line secrets
            DB_PASS=todo-db-password:latest

        # Step 4: Runs a health check on the private URL
      - name: Test Staging Revision
        run: |
          echo "Testing new revision at ${{ steps.deploy_staging.outputs.url }}"
          curl --retry 5 --retry-delay 10 --retry-connrefused --fail ${{ steps.deploy_staging.outputs.url }}/
          echo "✅ Staging revision test passed!"

        # Step 5: If test succeeds, pushes traffic to current revision
      - name: Promote Revision to Production
        if: success()
        run: |
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --to-revisions=LATEST=100 \
            --region=${{ env.REGION }}
          echo "✅ New revision is now live."
